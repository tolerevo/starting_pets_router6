{"ast":null,"code":"var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = {\n    exports: {}\n  }).exports, mod), mod.exports;\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n      get: () => from[key],\n      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n    });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n  value: mod,\n  enumerable: true\n}) : target, mod));\n\n// node_modules/set-cookie-parser/lib/set-cookie.js\nvar require_set_cookie = __commonJS({\n  \"node_modules/set-cookie-parser/lib/set-cookie.js\"(exports, module) {\n    \"use strict\";\n\n    var defaultParseOptions = {\n      decodeValues: true,\n      map: false,\n      silent: false\n    };\n    function isNonEmptyString(str) {\n      return typeof str === \"string\" && !!str.trim();\n    }\n    function parseString(setCookieValue, options) {\n      var parts = setCookieValue.split(\";\").filter(isNonEmptyString);\n      var nameValuePairStr = parts.shift();\n      var parsed = parseNameValuePair(nameValuePairStr);\n      var name = parsed.name;\n      var value = parsed.value;\n      options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;\n      try {\n        value = options.decodeValues ? decodeURIComponent(value) : value;\n      } catch (e) {\n        console.error(\"set-cookie-parser encountered an error while decoding a cookie with value '\" + value + \"'. Set options.decodeValues to false to disable this feature.\", e);\n      }\n      var cookie = {\n        name,\n        value\n      };\n      parts.forEach(function (part) {\n        var sides = part.split(\"=\");\n        var key = sides.shift().trimLeft().toLowerCase();\n        var value2 = sides.join(\"=\");\n        if (key === \"expires\") {\n          cookie.expires = new Date(value2);\n        } else if (key === \"max-age\") {\n          cookie.maxAge = parseInt(value2, 10);\n        } else if (key === \"secure\") {\n          cookie.secure = true;\n        } else if (key === \"httponly\") {\n          cookie.httpOnly = true;\n        } else if (key === \"samesite\") {\n          cookie.sameSite = value2;\n        } else {\n          cookie[key] = value2;\n        }\n      });\n      return cookie;\n    }\n    function parseNameValuePair(nameValuePairStr) {\n      var name = \"\";\n      var value = \"\";\n      var nameValueArr = nameValuePairStr.split(\"=\");\n      if (nameValueArr.length > 1) {\n        name = nameValueArr.shift();\n        value = nameValueArr.join(\"=\");\n      } else {\n        value = nameValuePairStr;\n      }\n      return {\n        name,\n        value\n      };\n    }\n    function parse(input, options) {\n      options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;\n      if (!input) {\n        if (!options.map) {\n          return [];\n        } else {\n          return {};\n        }\n      }\n      if (input.headers) {\n        if (typeof input.headers.getSetCookie === \"function\") {\n          input = input.headers.getSetCookie();\n        } else if (input.headers[\"set-cookie\"]) {\n          input = input.headers[\"set-cookie\"];\n        } else {\n          var sch = input.headers[Object.keys(input.headers).find(function (key) {\n            return key.toLowerCase() === \"set-cookie\";\n          })];\n          if (!sch && input.headers.cookie && !options.silent) {\n            console.warn(\"Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning.\");\n          }\n          input = sch;\n        }\n      }\n      if (!Array.isArray(input)) {\n        input = [input];\n      }\n      options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;\n      if (!options.map) {\n        return input.filter(isNonEmptyString).map(function (str) {\n          return parseString(str, options);\n        });\n      } else {\n        var cookies = {};\n        return input.filter(isNonEmptyString).reduce(function (cookies2, str) {\n          var cookie = parseString(str, options);\n          cookies2[cookie.name] = cookie;\n          return cookies2;\n        }, cookies);\n      }\n    }\n    function splitCookiesString(cookiesString) {\n      if (Array.isArray(cookiesString)) {\n        return cookiesString;\n      }\n      if (typeof cookiesString !== \"string\") {\n        return [];\n      }\n      var cookiesStrings = [];\n      var pos = 0;\n      var start;\n      var ch;\n      var lastComma;\n      var nextStart;\n      var cookiesSeparatorFound;\n      function skipWhitespace() {\n        while (pos < cookiesString.length && /\\s/.test(cookiesString.charAt(pos))) {\n          pos += 1;\n        }\n        return pos < cookiesString.length;\n      }\n      function notSpecialChar() {\n        ch = cookiesString.charAt(pos);\n        return ch !== \"=\" && ch !== \";\" && ch !== \",\";\n      }\n      while (pos < cookiesString.length) {\n        start = pos;\n        cookiesSeparatorFound = false;\n        while (skipWhitespace()) {\n          ch = cookiesString.charAt(pos);\n          if (ch === \",\") {\n            lastComma = pos;\n            pos += 1;\n            skipWhitespace();\n            nextStart = pos;\n            while (pos < cookiesString.length && notSpecialChar()) {\n              pos += 1;\n            }\n            if (pos < cookiesString.length && cookiesString.charAt(pos) === \"=\") {\n              cookiesSeparatorFound = true;\n              pos = nextStart;\n              cookiesStrings.push(cookiesString.substring(start, lastComma));\n              start = pos;\n            } else {\n              pos = lastComma + 1;\n            }\n          } else {\n            pos += 1;\n          }\n        }\n        if (!cookiesSeparatorFound || pos >= cookiesString.length) {\n          cookiesStrings.push(cookiesString.substring(start, cookiesString.length));\n        }\n      }\n      return cookiesStrings;\n    }\n    module.exports = parse;\n    module.exports.parse = parse;\n    module.exports.parseString = parseString;\n    module.exports.splitCookiesString = splitCookiesString;\n  }\n});\n\n// src/store.ts\nvar import_set_cookie_parser = __toESM(require_set_cookie());\nvar PERSISTENCY_KEY = \"MSW_COOKIE_STORE\";\nfunction supportsLocalStorage() {\n  try {\n    if (localStorage == null) {\n      return false;\n    }\n    const testKey = PERSISTENCY_KEY + \"_test\";\n    localStorage.setItem(testKey, \"test\");\n    localStorage.getItem(testKey);\n    localStorage.removeItem(testKey);\n    return true;\n  } catch (error) {\n    return false;\n  }\n}\nfunction isPropertyAccessible(object, method) {\n  try {\n    object[method];\n    return true;\n  } catch {\n    return false;\n  }\n}\nvar CookieStore = class {\n  constructor() {\n    this.store = /* @__PURE__ */new Map();\n  }\n  add(request, response) {\n    if (isPropertyAccessible(request, \"credentials\") && request.credentials === \"omit\") {\n      return;\n    }\n    const requestUrl = new URL(request.url);\n    const responseCookies = response.headers.get(\"set-cookie\");\n    if (!responseCookies) {\n      return;\n    }\n    const now = Date.now();\n    const parsedResponseCookies = (0, import_set_cookie_parser.parse)(responseCookies).map(_ref => {\n      let {\n        maxAge,\n        ...cookie\n      } = _ref;\n      return {\n        ...cookie,\n        expires: maxAge === void 0 ? cookie.expires : new Date(now + maxAge * 1e3),\n        maxAge\n      };\n    });\n    const prevCookies = this.store.get(requestUrl.origin) || /* @__PURE__ */new Map();\n    parsedResponseCookies.forEach(cookie => {\n      this.store.set(requestUrl.origin, prevCookies.set(cookie.name, cookie));\n    });\n  }\n  get(request) {\n    this.deleteExpiredCookies();\n    const requestUrl = new URL(request.url);\n    const originCookies = this.store.get(requestUrl.origin) || /* @__PURE__ */new Map();\n    if (!isPropertyAccessible(request, \"credentials\")) {\n      return originCookies;\n    }\n    switch (request.credentials) {\n      case \"include\":\n        {\n          if (typeof document === \"undefined\") {\n            return originCookies;\n          }\n          const documentCookies = (0, import_set_cookie_parser.parse)(document.cookie);\n          documentCookies.forEach(cookie => {\n            originCookies.set(cookie.name, cookie);\n          });\n          return originCookies;\n        }\n      case \"same-origin\":\n        {\n          return originCookies;\n        }\n      default:\n        return /* @__PURE__ */new Map();\n    }\n  }\n  getAll() {\n    this.deleteExpiredCookies();\n    return this.store;\n  }\n  deleteAll(request) {\n    const requestUrl = new URL(request.url);\n    this.store.delete(requestUrl.origin);\n  }\n  clear() {\n    this.store.clear();\n  }\n  hydrate() {\n    if (!supportsLocalStorage()) {\n      return;\n    }\n    const persistedCookies = localStorage.getItem(PERSISTENCY_KEY);\n    if (!persistedCookies) {\n      return;\n    }\n    try {\n      const parsedCookies = JSON.parse(persistedCookies);\n      parsedCookies.forEach(_ref2 => {\n        let [origin, cookies] = _ref2;\n        this.store.set(origin, new Map(cookies.map(_ref3 => {\n          let [token, {\n            expires,\n            ...cookie\n          }] = _ref3;\n          return [token, expires === void 0 ? cookie : {\n            ...cookie,\n            expires: new Date(expires)\n          }];\n        })));\n      });\n    } catch (error) {\n      console.warn(`\n[virtual-cookie] Failed to parse a stored cookie from the localStorage (key \"${PERSISTENCY_KEY}\").\n\nStored value:\n${localStorage.getItem(PERSISTENCY_KEY)}\n\nThrown exception:\n${error}\n\nInvalid value has been removed from localStorage to prevent subsequent failed parsing attempts.`);\n      localStorage.removeItem(PERSISTENCY_KEY);\n    }\n  }\n  persist() {\n    if (!supportsLocalStorage()) {\n      return;\n    }\n    const serializedCookies = Array.from(this.store.entries()).map(_ref4 => {\n      let [origin, cookies] = _ref4;\n      return [origin, Array.from(cookies.entries())];\n    });\n    localStorage.setItem(PERSISTENCY_KEY, JSON.stringify(serializedCookies));\n  }\n  deleteExpiredCookies() {\n    const now = Date.now();\n    this.store.forEach((originCookies, origin) => {\n      originCookies.forEach(_ref5 => {\n        let {\n          expires,\n          name\n        } = _ref5;\n        if (expires !== void 0 && expires.getTime() <= now) {\n          originCookies.delete(name);\n        }\n      });\n      if (originCookies.size === 0) {\n        this.store.delete(origin);\n      }\n    });\n  }\n};\nvar store = new CookieStore();\nexport { PERSISTENCY_KEY, store };","map":{"version":3,"mappings":"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","names":["defaultParseOptions","decodeValues","map","silent","isNonEmptyString","str","trim","parseString","setCookieValue","options","parts","split","filter","nameValuePairStr","shift","parsed","parseNameValuePair","name","value","Object","assign","decodeURIComponent","e","console","error","cookie","forEach","part","sides","key","trimLeft","toLowerCase","join","expires","Date","maxAge","parseInt","secure","httpOnly","sameSite","nameValueArr","length","parse","input","headers","getSetCookie","sch","keys","find","warn","Array","isArray","cookies","reduce","splitCookiesString","cookiesString","cookiesStrings","pos","start","ch","lastComma","nextStart","cookiesSeparatorFound","skipWhitespace","test","charAt","notSpecialChar","push","substring","module","exports","__toESM","PERSISTENCY_KEY","supportsLocalStorage","localStorage","testKey","setItem","getItem","removeItem","isPropertyAccessible","object","method","CookieStore","constructor","store","Map","add","request","response","credentials","requestUrl","URL","url","responseCookies","get","now","parsedResponseCookies","import_set_cookie_parser","_ref","prevCookies","origin","set","deleteExpiredCookies","originCookies","document","documentCookies","getAll","deleteAll","delete","clear","hydrate","persistedCookies","parsedCookies","JSON","_ref2","_ref3","token","persist","serializedCookies","from","entries","_ref4","stringify","_ref5","getTime","size"],"sources":["/Users/ditole/Desktop/projects/pets-store/node_modules/@mswjs/cookies/node_modules/set-cookie-parser/lib/set-cookie.js","/Users/ditole/Desktop/projects/pets-store/node_modules/@mswjs/cookies/src/store.ts"],"sourcesContent":["\"use strict\";\n\nvar defaultParseOptions = {\n  decodeValues: true,\n  map: false,\n  silent: false,\n};\n\nfunction isNonEmptyString(str) {\n  return typeof str === \"string\" && !!str.trim();\n}\n\nfunction parseString(setCookieValue, options) {\n  var parts = setCookieValue.split(\";\").filter(isNonEmptyString);\n\n  var nameValuePairStr = parts.shift();\n  var parsed = parseNameValuePair(nameValuePairStr);\n  var name = parsed.name;\n  var value = parsed.value;\n\n  options = options\n    ? Object.assign({}, defaultParseOptions, options)\n    : defaultParseOptions;\n\n  try {\n    value = options.decodeValues ? decodeURIComponent(value) : value; // decode cookie value\n  } catch (e) {\n    console.error(\n      \"set-cookie-parser encountered an error while decoding a cookie with value '\" +\n        value +\n        \"'. Set options.decodeValues to false to disable this feature.\",\n      e\n    );\n  }\n\n  var cookie = {\n    name: name,\n    value: value,\n  };\n\n  parts.forEach(function (part) {\n    var sides = part.split(\"=\");\n    var key = sides.shift().trimLeft().toLowerCase();\n    var value = sides.join(\"=\");\n    if (key === \"expires\") {\n      cookie.expires = new Date(value);\n    } else if (key === \"max-age\") {\n      cookie.maxAge = parseInt(value, 10);\n    } else if (key === \"secure\") {\n      cookie.secure = true;\n    } else if (key === \"httponly\") {\n      cookie.httpOnly = true;\n    } else if (key === \"samesite\") {\n      cookie.sameSite = value;\n    } else {\n      cookie[key] = value;\n    }\n  });\n\n  return cookie;\n}\n\nfunction parseNameValuePair(nameValuePairStr) {\n  // Parses name-value-pair according to rfc6265bis draft\n\n  var name = \"\";\n  var value = \"\";\n  var nameValueArr = nameValuePairStr.split(\"=\");\n  if (nameValueArr.length > 1) {\n    name = nameValueArr.shift();\n    value = nameValueArr.join(\"=\"); // everything after the first =, joined by a \"=\" if there was more than one part\n  } else {\n    value = nameValuePairStr;\n  }\n\n  return { name: name, value: value };\n}\n\nfunction parse(input, options) {\n  options = options\n    ? Object.assign({}, defaultParseOptions, options)\n    : defaultParseOptions;\n\n  if (!input) {\n    if (!options.map) {\n      return [];\n    } else {\n      return {};\n    }\n  }\n\n  if (input.headers) {\n    if (typeof input.headers.getSetCookie === \"function\") {\n      // for fetch responses - they combine headers of the same type in the headers array,\n      // but getSetCookie returns an uncombined array\n      input = input.headers.getSetCookie();\n    } else if (input.headers[\"set-cookie\"]) {\n      // fast-path for node.js (which automatically normalizes header names to lower-case\n      input = input.headers[\"set-cookie\"];\n    } else {\n      // slow-path for other environments - see #25\n      var sch =\n        input.headers[\n          Object.keys(input.headers).find(function (key) {\n            return key.toLowerCase() === \"set-cookie\";\n          })\n        ];\n      // warn if called on a request-like object with a cookie header rather than a set-cookie header - see #34, 36\n      if (!sch && input.headers.cookie && !options.silent) {\n        console.warn(\n          \"Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning.\"\n        );\n      }\n      input = sch;\n    }\n  }\n  if (!Array.isArray(input)) {\n    input = [input];\n  }\n\n  options = options\n    ? Object.assign({}, defaultParseOptions, options)\n    : defaultParseOptions;\n\n  if (!options.map) {\n    return input.filter(isNonEmptyString).map(function (str) {\n      return parseString(str, options);\n    });\n  } else {\n    var cookies = {};\n    return input.filter(isNonEmptyString).reduce(function (cookies, str) {\n      var cookie = parseString(str, options);\n      cookies[cookie.name] = cookie;\n      return cookies;\n    }, cookies);\n  }\n}\n\n/*\n  Set-Cookie header field-values are sometimes comma joined in one string. This splits them without choking on commas\n  that are within a single set-cookie field-value, such as in the Expires portion.\n\n  This is uncommon, but explicitly allowed - see https://tools.ietf.org/html/rfc2616#section-4.2\n  Node.js does this for every header *except* set-cookie - see https://github.com/nodejs/node/blob/d5e363b77ebaf1caf67cd7528224b651c86815c1/lib/_http_incoming.js#L128\n  React Native's fetch does this for *every* header, including set-cookie.\n\n  Based on: https://github.com/google/j2objc/commit/16820fdbc8f76ca0c33472810ce0cb03d20efe25\n  Credits to: https://github.com/tomball for original and https://github.com/chrusart for JavaScript implementation\n*/\nfunction splitCookiesString(cookiesString) {\n  if (Array.isArray(cookiesString)) {\n    return cookiesString;\n  }\n  if (typeof cookiesString !== \"string\") {\n    return [];\n  }\n\n  var cookiesStrings = [];\n  var pos = 0;\n  var start;\n  var ch;\n  var lastComma;\n  var nextStart;\n  var cookiesSeparatorFound;\n\n  function skipWhitespace() {\n    while (pos < cookiesString.length && /\\s/.test(cookiesString.charAt(pos))) {\n      pos += 1;\n    }\n    return pos < cookiesString.length;\n  }\n\n  function notSpecialChar() {\n    ch = cookiesString.charAt(pos);\n\n    return ch !== \"=\" && ch !== \";\" && ch !== \",\";\n  }\n\n  while (pos < cookiesString.length) {\n    start = pos;\n    cookiesSeparatorFound = false;\n\n    while (skipWhitespace()) {\n      ch = cookiesString.charAt(pos);\n      if (ch === \",\") {\n        // ',' is a cookie separator if we have later first '=', not ';' or ','\n        lastComma = pos;\n        pos += 1;\n\n        skipWhitespace();\n        nextStart = pos;\n\n        while (pos < cookiesString.length && notSpecialChar()) {\n          pos += 1;\n        }\n\n        // currently special character\n        if (pos < cookiesString.length && cookiesString.charAt(pos) === \"=\") {\n          // we found cookies separator\n          cookiesSeparatorFound = true;\n          // pos is inside the next cookie, so back up and return it.\n          pos = nextStart;\n          cookiesStrings.push(cookiesString.substring(start, lastComma));\n          start = pos;\n        } else {\n          // in param ',' or param separator ';',\n          // we continue from that comma\n          pos = lastComma + 1;\n        }\n      } else {\n        pos += 1;\n      }\n    }\n\n    if (!cookiesSeparatorFound || pos >= cookiesString.length) {\n      cookiesStrings.push(cookiesString.substring(start, cookiesString.length));\n    }\n  }\n\n  return cookiesStrings;\n}\n\nmodule.exports = parse;\nmodule.exports.parse = parse;\nmodule.exports.parseString = parseString;\nmodule.exports.splitCookiesString = splitCookiesString;\n","import { Cookie, parse as parseCookie } from 'set-cookie-parser'\n\ninterface RequestLike {\n  credentials: Request['credentials']\n  url: string\n}\n\ninterface HeadersLike {\n  get(name: string): string | null\n}\n\ninterface ResponseLike {\n  headers: HeadersLike\n}\n\nexport type Store = Map<string, StoreEntry>\nexport type StoreEntry = Map<string, Cookie>\nexport type CookieString = Omit<Cookie, 'expires'> & { expires?: string }\n\nexport const PERSISTENCY_KEY = 'MSW_COOKIE_STORE'\n\nfunction supportsLocalStorage() {\n  try {\n    if (localStorage == null) {\n      return false\n    }\n\n    const testKey = PERSISTENCY_KEY + '_test'\n\n    localStorage.setItem(testKey, 'test')\n    localStorage.getItem(testKey)\n    localStorage.removeItem(testKey)\n\n    return true\n  } catch (error) {\n    return false\n  }\n}\n\n/**\n * Checks that accessing a given property on an object\n * by name does not throw an error.\n *\n * This is generally used to avoid issues in environments\n * like `miniflare` where some properties are defined as getters\n * where accessing that property throws directly.\n */\nfunction isPropertyAccessible<Obj extends Record<string, any>>(\n  object: Obj,\n  method: keyof Obj,\n) {\n  try {\n    object[method]\n    return true\n  } catch {\n    return false\n  }\n}\n\nclass CookieStore {\n  private store: Store\n\n  constructor() {\n    this.store = new Map()\n  }\n\n  /**\n   * Sets the given request cookies into the store.\n   * Respects the `request.credentials` policy.\n   */\n  add(request: RequestLike, response: ResponseLike): void {\n    if (\n      isPropertyAccessible(request, 'credentials') &&\n      request.credentials === 'omit'\n    ) {\n      return\n    }\n\n    const requestUrl = new URL(request.url)\n    const responseCookies = response.headers.get('set-cookie')\n\n    if (!responseCookies) {\n      return\n    }\n\n    const now = Date.now()\n    const parsedResponseCookies = parseCookie(responseCookies).map(\n      ({ maxAge, ...cookie }) => ({\n        ...cookie,\n        expires:\n          maxAge === undefined ? cookie.expires : new Date(now + maxAge * 1000),\n        maxAge,\n      }),\n    )\n\n    const prevCookies =\n      this.store.get(requestUrl.origin) || new Map<string, Cookie>()\n\n    parsedResponseCookies.forEach((cookie) => {\n      this.store.set(requestUrl.origin, prevCookies.set(cookie.name, cookie))\n    })\n  }\n\n  /**\n   * Returns cookies relevant to the given request\n   * and its `request.credentials` policy.\n   */\n  get(request: RequestLike): StoreEntry {\n    this.deleteExpiredCookies()\n\n    const requestUrl = new URL(request.url)\n    const originCookies =\n      this.store.get(requestUrl.origin) || new Map<string, Cookie>()\n\n    if (!isPropertyAccessible(request, 'credentials')) {\n      return originCookies\n    }\n\n    switch (request.credentials) {\n      case 'include': {\n        // Support running this method in Node.js.\n        if (typeof document === 'undefined') {\n          return originCookies\n        }\n\n        const documentCookies = parseCookie(document.cookie)\n\n        documentCookies.forEach((cookie) => {\n          originCookies.set(cookie.name, cookie)\n        })\n\n        return originCookies\n      }\n\n      case 'same-origin': {\n        return originCookies\n      }\n\n      default:\n        return new Map()\n    }\n  }\n\n  /**\n   * Returns a collection of all stored cookies.\n   */\n  getAll(): Store {\n    this.deleteExpiredCookies()\n    return this.store\n  }\n\n  /**\n   * Deletes all cookies associated with the given request.\n   */\n  deleteAll(request: RequestLike): void {\n    const requestUrl = new URL(request.url)\n    this.store.delete(requestUrl.origin)\n  }\n\n  /**\n   * Clears the entire cookie store.\n   */\n  clear(): void {\n    this.store.clear()\n  }\n\n  /**\n   * Hydrates the virtual cookie store from the `localStorage` if defined.\n   */\n  hydrate(): void {\n    if (!supportsLocalStorage()) {\n      return\n    }\n\n    const persistedCookies = localStorage.getItem(PERSISTENCY_KEY)\n\n    if (!persistedCookies) {\n      return\n    }\n\n    try {\n      const parsedCookies: [string, [string, CookieString][]][] =\n        JSON.parse(persistedCookies)\n\n      parsedCookies.forEach(([origin, cookies]) => {\n        this.store.set(\n          origin,\n          new Map(\n            cookies.map(([token, { expires, ...cookie }]) => [\n              token,\n              expires === undefined\n                ? cookie\n                : { ...cookie, expires: new Date(expires) },\n            ]),\n          ),\n        )\n      })\n    } catch (error) {\n      console.warn(`\n[virtual-cookie] Failed to parse a stored cookie from the localStorage (key \"${PERSISTENCY_KEY}\").\n\nStored value:\n${localStorage.getItem(PERSISTENCY_KEY)}\n\nThrown exception:\n${error}\n\nInvalid value has been removed from localStorage to prevent subsequent failed parsing attempts.`)\n      localStorage.removeItem(PERSISTENCY_KEY)\n    }\n  }\n\n  /**\n   * Persists the current virtual cookies into the `localStorage` if defined,\n   * so they are available on the next page load.\n   */\n  persist(): void {\n    if (!supportsLocalStorage()) {\n      return\n    }\n\n    const serializedCookies = Array.from(this.store.entries()).map(\n      ([origin, cookies]) => {\n        return [origin, Array.from(cookies.entries())]\n      },\n    )\n\n    localStorage.setItem(PERSISTENCY_KEY, JSON.stringify(serializedCookies))\n  }\n\n  private deleteExpiredCookies() {\n    const now = Date.now()\n\n    this.store.forEach((originCookies, origin) => {\n      originCookies.forEach(({ expires, name }) => {\n        if (expires !== undefined && expires.getTime() <= now) {\n          originCookies.delete(name)\n        }\n      })\n\n      if (originCookies.size === 0) {\n        this.store.delete(origin)\n      }\n    })\n  }\n}\n\nexport const store = new CookieStore()\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}