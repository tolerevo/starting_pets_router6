{"ast":null,"code":"// src/glossary.ts\nvar IS_PATCHED_MODULE = Symbol(\"isPatchedModule\");\n\n// src/Interceptor.ts\nimport { Logger } from \"@open-draft/logger\";\nimport { Emitter } from \"strict-event-emitter\";\nfunction getGlobalSymbol(symbol) {\n  return (\n    // @ts-ignore https://github.com/Microsoft/TypeScript/issues/24587\n    globalThis[symbol] || void 0\n  );\n}\nfunction setGlobalSymbol(symbol, value) {\n  globalThis[symbol] = value;\n}\nfunction deleteGlobalSymbol(symbol) {\n  delete globalThis[symbol];\n}\nvar InterceptorReadyState = /* @__PURE__ */(InterceptorReadyState2 => {\n  InterceptorReadyState2[\"INACTIVE\"] = \"INACTIVE\";\n  InterceptorReadyState2[\"APPLYING\"] = \"APPLYING\";\n  InterceptorReadyState2[\"APPLIED\"] = \"APPLIED\";\n  InterceptorReadyState2[\"DISPOSING\"] = \"DISPOSING\";\n  InterceptorReadyState2[\"DISPOSED\"] = \"DISPOSED\";\n  return InterceptorReadyState2;\n})(InterceptorReadyState || {});\nvar Interceptor = class {\n  constructor(symbol) {\n    this.symbol = symbol;\n    this.readyState = \"INACTIVE\" /* INACTIVE */;\n    this.emitter = new Emitter();\n    this.subscriptions = [];\n    this.logger = new Logger(symbol.description);\n    this.emitter.setMaxListeners(0);\n    this.logger.info(\"constructing the interceptor...\");\n  }\n  /**\n   * Determine if this interceptor can be applied\n   * in the current environment.\n   */\n  checkEnvironment() {\n    return true;\n  }\n  /**\n   * Apply this interceptor to the current process.\n   * Returns an already running interceptor instance if it's present.\n   */\n  apply() {\n    const logger = this.logger.extend(\"apply\");\n    logger.info(\"applying the interceptor...\");\n    if (this.readyState === \"APPLIED\" /* APPLIED */) {\n      logger.info(\"intercepted already applied!\");\n      return;\n    }\n    const shouldApply = this.checkEnvironment();\n    if (!shouldApply) {\n      logger.info(\"the interceptor cannot be applied in this environment!\");\n      return;\n    }\n    this.readyState = \"APPLYING\" /* APPLYING */;\n    const runningInstance = this.getInstance();\n    if (runningInstance) {\n      logger.info(\"found a running instance, reusing...\");\n      this.on = (event, listener) => {\n        logger.info('proxying the \"%s\" listener', event);\n        runningInstance.emitter.addListener(event, listener);\n        this.subscriptions.push(() => {\n          runningInstance.emitter.removeListener(event, listener);\n          logger.info('removed proxied \"%s\" listener!', event);\n        });\n        return this;\n      };\n      this.readyState = \"APPLIED\" /* APPLIED */;\n      return;\n    }\n    logger.info(\"no running instance found, setting up a new instance...\");\n    this.setup();\n    this.setInstance();\n    this.readyState = \"APPLIED\" /* APPLIED */;\n  }\n  /**\n   * Setup the module augments and stubs necessary for this interceptor.\n   * This method is not run if there's a running interceptor instance\n   * to prevent instantiating an interceptor multiple times.\n   */\n  setup() {}\n  /**\n   * Listen to the interceptor's public events.\n   */\n  on(event, listener) {\n    const logger = this.logger.extend(\"on\");\n    if (this.readyState === \"DISPOSING\" /* DISPOSING */ || this.readyState === \"DISPOSED\" /* DISPOSED */) {\n      logger.info(\"cannot listen to events, already disposed!\");\n      return this;\n    }\n    logger.info('adding \"%s\" event listener:', event, listener);\n    this.emitter.on(event, listener);\n    return this;\n  }\n  once(event, listener) {\n    this.emitter.once(event, listener);\n    return this;\n  }\n  off(event, listener) {\n    this.emitter.off(event, listener);\n    return this;\n  }\n  removeAllListeners(event) {\n    this.emitter.removeAllListeners(event);\n    return this;\n  }\n  /**\n   * Disposes of any side-effects this interceptor has introduced.\n   */\n  dispose() {\n    const logger = this.logger.extend(\"dispose\");\n    if (this.readyState === \"DISPOSED\" /* DISPOSED */) {\n      logger.info(\"cannot dispose, already disposed!\");\n      return;\n    }\n    logger.info(\"disposing the interceptor...\");\n    this.readyState = \"DISPOSING\" /* DISPOSING */;\n    if (!this.getInstance()) {\n      logger.info(\"no interceptors running, skipping dispose...\");\n      return;\n    }\n    this.clearInstance();\n    logger.info(\"global symbol deleted:\", getGlobalSymbol(this.symbol));\n    if (this.subscriptions.length > 0) {\n      logger.info(\"disposing of %d subscriptions...\", this.subscriptions.length);\n      for (const dispose of this.subscriptions) {\n        dispose();\n      }\n      this.subscriptions = [];\n      logger.info(\"disposed of all subscriptions!\", this.subscriptions.length);\n    }\n    this.emitter.removeAllListeners();\n    logger.info(\"destroyed the listener!\");\n    this.readyState = \"DISPOSED\" /* DISPOSED */;\n  }\n  getInstance() {\n    var _a;\n    const instance = getGlobalSymbol(this.symbol);\n    this.logger.info(\"retrieved global instance:\", (_a = instance == null ? void 0 : instance.constructor) == null ? void 0 : _a.name);\n    return instance;\n  }\n  setInstance() {\n    setGlobalSymbol(this.symbol, this);\n    this.logger.info(\"set global instance!\", this.symbol.description);\n  }\n  clearInstance() {\n    deleteGlobalSymbol(this.symbol);\n    this.logger.info(\"cleared global instance!\", this.symbol.description);\n  }\n};\nexport { IS_PATCHED_MODULE, getGlobalSymbol, deleteGlobalSymbol, InterceptorReadyState, Interceptor };","map":{"version":3,"mappings":"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","names":["IS_PATCHED_MODULE","Symbol","Logger","Emitter","getGlobalSymbol","symbol","globalThis","setGlobalSymbol","value","deleteGlobalSymbol","InterceptorReadyState","Interceptor","constructor","readyState","emitter","subscriptions","logger","description","setMaxListeners","info","checkEnvironment","apply","extend","shouldApply","runningInstance","getInstance","on","event","listener","addListener","push","removeListener","setup","setInstance","once","off","removeAllListeners","dispose","clearInstance","length","instance","_a","name"],"sources":["/Users/ditole/Desktop/projects/pets-store/node_modules/@mswjs/interceptors/src/glossary.ts","/Users/ditole/Desktop/projects/pets-store/node_modules/@mswjs/interceptors/src/Interceptor.ts"],"sourcesContent":["import type { InteractiveRequest } from './utils/toInteractiveRequest'\n\nexport const IS_PATCHED_MODULE: unique symbol = Symbol('isPatchedModule')\n\nexport type RequestCredentials = 'omit' | 'include' | 'same-origin'\n\nexport type HttpRequestEventMap = {\n  request: [\n    args: {\n      request: InteractiveRequest\n      requestId: string\n    }\n  ]\n  response: [\n    args: {\n      response: Response\n      isMockedResponse: boolean\n      request: Request\n      requestId: string\n    }\n  ]\n}\n","import { Logger } from '@open-draft/logger'\nimport { Emitter, EventMap, Listener } from 'strict-event-emitter'\n\nexport type InterceptorEventMap = Record<string, any>\nexport type InterceptorSubscription = () => void\n\nexport function getGlobalSymbol<V>(symbol: Symbol): V | undefined {\n  return (\n    // @ts-ignore https://github.com/Microsoft/TypeScript/issues/24587\n    globalThis[symbol] || undefined\n  )\n}\n\nfunction setGlobalSymbol(symbol: Symbol, value: any): void {\n  // @ts-ignore\n  globalThis[symbol] = value\n}\n\nexport function deleteGlobalSymbol(symbol: Symbol): void {\n  // @ts-ignore\n  delete globalThis[symbol]\n}\n\nexport enum InterceptorReadyState {\n  INACTIVE = 'INACTIVE',\n  APPLYING = 'APPLYING',\n  APPLIED = 'APPLIED',\n  DISPOSING = 'DISPOSING',\n  DISPOSED = 'DISPOSED',\n}\n\nexport type ExtractEventNames<Events extends Record<string, any>> =\n  Events extends Record<infer EventName, any> ? EventName : never\n\nexport class Interceptor<Events extends InterceptorEventMap> {\n  protected emitter: Emitter<Events>\n  protected subscriptions: Array<InterceptorSubscription>\n  protected logger: Logger\n\n  public readyState: InterceptorReadyState\n\n  constructor(private readonly symbol: symbol) {\n    this.readyState = InterceptorReadyState.INACTIVE\n\n    this.emitter = new Emitter()\n    this.subscriptions = []\n    this.logger = new Logger(symbol.description!)\n\n    // Do not limit the maximum number of listeners\n    // so not to limit the maximum amount of parallel events emitted.\n    this.emitter.setMaxListeners(0)\n\n    this.logger.info('constructing the interceptor...')\n  }\n\n  /**\n   * Determine if this interceptor can be applied\n   * in the current environment.\n   */\n  protected checkEnvironment(): boolean {\n    return true\n  }\n\n  /**\n   * Apply this interceptor to the current process.\n   * Returns an already running interceptor instance if it's present.\n   */\n  public apply(): void {\n    const logger = this.logger.extend('apply')\n    logger.info('applying the interceptor...')\n\n    if (this.readyState === InterceptorReadyState.APPLIED) {\n      logger.info('intercepted already applied!')\n      return\n    }\n\n    const shouldApply = this.checkEnvironment()\n\n    if (!shouldApply) {\n      logger.info('the interceptor cannot be applied in this environment!')\n      return\n    }\n\n    this.readyState = InterceptorReadyState.APPLYING\n\n    // Whenever applying a new interceptor, check if it hasn't been applied already.\n    // This enables to apply the same interceptor multiple times, for example from a different\n    // interceptor, only proxying events but keeping the stubs in a single place.\n    const runningInstance = this.getInstance()\n\n    if (runningInstance) {\n      logger.info('found a running instance, reusing...')\n\n      // Proxy any listeners you set on this instance to the running instance.\n      this.on = (event, listener) => {\n        logger.info('proxying the \"%s\" listener', event)\n\n        // Add listeners to the running instance so they appear\n        // at the top of the event listeners list and are executed first.\n        runningInstance.emitter.addListener(event, listener)\n\n        // Ensure that once this interceptor instance is disposed,\n        // it removes all listeners it has appended to the running interceptor instance.\n        this.subscriptions.push(() => {\n          runningInstance.emitter.removeListener(event, listener)\n          logger.info('removed proxied \"%s\" listener!', event)\n        })\n\n        return this\n      }\n\n      this.readyState = InterceptorReadyState.APPLIED\n\n      return\n    }\n\n    logger.info('no running instance found, setting up a new instance...')\n\n    // Setup the interceptor.\n    this.setup()\n\n    // Store the newly applied interceptor instance globally.\n    this.setInstance()\n\n    this.readyState = InterceptorReadyState.APPLIED\n  }\n\n  /**\n   * Setup the module augments and stubs necessary for this interceptor.\n   * This method is not run if there's a running interceptor instance\n   * to prevent instantiating an interceptor multiple times.\n   */\n  protected setup(): void {}\n\n  /**\n   * Listen to the interceptor's public events.\n   */\n  public on<EventName extends ExtractEventNames<Events>>(\n    event: EventName,\n    listener: Listener<Events[EventName]>\n  ): this {\n    const logger = this.logger.extend('on')\n\n    if (\n      this.readyState === InterceptorReadyState.DISPOSING ||\n      this.readyState === InterceptorReadyState.DISPOSED\n    ) {\n      logger.info('cannot listen to events, already disposed!')\n      return this\n    }\n\n    logger.info('adding \"%s\" event listener:', event, listener)\n\n    this.emitter.on(event, listener)\n    return this\n  }\n\n  public once<EventName extends ExtractEventNames<Events>>(\n    event: EventName,\n    listener: Listener<Events[EventName]>\n  ): this {\n    this.emitter.once(event, listener)\n    return this\n  }\n\n  public off<EventName extends ExtractEventNames<Events>>(\n    event: EventName,\n    listener: Listener<Events[EventName]>\n  ): this {\n    this.emitter.off(event, listener)\n    return this\n  }\n\n  public removeAllListeners<EventName extends ExtractEventNames<Events>>(\n    event?: EventName\n  ): this {\n    this.emitter.removeAllListeners(event)\n    return this\n  }\n\n  /**\n   * Disposes of any side-effects this interceptor has introduced.\n   */\n  public dispose(): void {\n    const logger = this.logger.extend('dispose')\n\n    if (this.readyState === InterceptorReadyState.DISPOSED) {\n      logger.info('cannot dispose, already disposed!')\n      return\n    }\n\n    logger.info('disposing the interceptor...')\n    this.readyState = InterceptorReadyState.DISPOSING\n\n    if (!this.getInstance()) {\n      logger.info('no interceptors running, skipping dispose...')\n      return\n    }\n\n    // Delete the global symbol as soon as possible,\n    // indicating that the interceptor is no longer running.\n    this.clearInstance()\n\n    logger.info('global symbol deleted:', getGlobalSymbol(this.symbol))\n\n    if (this.subscriptions.length > 0) {\n      logger.info('disposing of %d subscriptions...', this.subscriptions.length)\n\n      for (const dispose of this.subscriptions) {\n        dispose()\n      }\n\n      this.subscriptions = []\n\n      logger.info('disposed of all subscriptions!', this.subscriptions.length)\n    }\n\n    this.emitter.removeAllListeners()\n    logger.info('destroyed the listener!')\n\n    this.readyState = InterceptorReadyState.DISPOSED\n  }\n\n  private getInstance(): this | undefined {\n    const instance = getGlobalSymbol<this>(this.symbol)\n    this.logger.info('retrieved global instance:', instance?.constructor?.name)\n    return instance\n  }\n\n  private setInstance(): void {\n    setGlobalSymbol(this.symbol, this)\n    this.logger.info('set global instance!', this.symbol.description)\n  }\n\n  private clearInstance(): void {\n    deleteGlobalSymbol(this.symbol)\n    this.logger.info('cleared global instance!', this.symbol.description)\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}