{"ast":null,"code":"// src/format.ts\nvar POSITIONALS_EXP = /(%?)(%([sdijo]))/g;\nfunction serializePositional(positional, flag) {\n  switch (flag) {\n    case \"s\":\n      return positional;\n    case \"d\":\n    case \"i\":\n      return Number(positional);\n    case \"j\":\n      return JSON.stringify(positional);\n    case \"o\":\n      {\n        if (typeof positional === \"string\") {\n          return positional;\n        }\n        const json = JSON.stringify(positional);\n        if (json === \"{}\" || json === \"[]\" || /^\\[object .+?\\]$/.test(json)) {\n          return positional;\n        }\n        return json;\n      }\n  }\n}\nfunction format(message) {\n  for (var _len = arguments.length, positionals = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    positionals[_key - 1] = arguments[_key];\n  }\n  if (positionals.length === 0) {\n    return message;\n  }\n  let positionalIndex = 0;\n  let formattedMessage = message.replace(POSITIONALS_EXP, (match, isEscaped, _, flag) => {\n    const positional = positionals[positionalIndex];\n    const value = serializePositional(positional, flag);\n    if (!isEscaped) {\n      positionalIndex++;\n      return value;\n    }\n    return match;\n  });\n  if (positionalIndex < positionals.length) {\n    formattedMessage += ` ${positionals.slice(positionalIndex).join(\" \")}`;\n  }\n  formattedMessage = formattedMessage.replace(/%{2,2}/g, \"%\");\n  return formattedMessage;\n}\n\n// src/invariant.ts\nvar STACK_FRAMES_TO_IGNORE = 2;\nfunction cleanErrorStack(error) {\n  if (!error.stack) {\n    return;\n  }\n  const nextStack = error.stack.split(\"\\n\");\n  nextStack.splice(1, STACK_FRAMES_TO_IGNORE);\n  error.stack = nextStack.join(\"\\n\");\n}\nvar InvariantError = class extends Error {\n  constructor(message) {\n    super(message);\n    this.message = message;\n    this.name = \"Invariant Violation\";\n    for (var _len2 = arguments.length, positionals = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      positionals[_key2 - 1] = arguments[_key2];\n    }\n    this.message = format(message, ...positionals);\n    cleanErrorStack(this);\n  }\n};\nvar invariant = function (predicate, message) {\n  if (!predicate) {\n    for (var _len3 = arguments.length, positionals = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n      positionals[_key3 - 2] = arguments[_key3];\n    }\n    throw new InvariantError(message, ...positionals);\n  }\n};\ninvariant.as = function (ErrorConstructor, predicate, message) {\n  if (!predicate) {\n    for (var _len4 = arguments.length, positionals = new Array(_len4 > 3 ? _len4 - 3 : 0), _key4 = 3; _key4 < _len4; _key4++) {\n      positionals[_key4 - 3] = arguments[_key4];\n    }\n    const formatMessage = positionals.length === 0 ? message : format(message, positionals);\n    let error;\n    try {\n      error = Reflect.construct(ErrorConstructor, [formatMessage]);\n    } catch (err) {\n      error = ErrorConstructor(formatMessage);\n    }\n    throw error;\n  }\n};\nexport { InvariantError, format, invariant };","map":{"version":3,"mappings":";AAAA,IAAMA,kBAAkB;AAExB,SAASC,oBAAoBC,YAAiBC,MAAmB;EAC/D,QAAQA;IAEN,KAAK;MACH,OAAOD;IAGT,KAAK;IACL,KAAK;MACH,OAAOE,OAAOF,UAAU;IAG1B,KAAK;MACH,OAAOG,KAAKC,UAAUJ,UAAU;IAGlC,KAAK;MAAK;QAER,IAAI,OAAOA,eAAe,UAAU;UAClC,OAAOA;QACT;QAEA,MAAMK,OAAOF,KAAKC,UAAUJ,UAAU;QAGtC,IAAIK,SAAS,QAAQA,SAAS,QAAQ,mBAAmBC,KAAKD,IAAI,GAAG;UACnE,OAAOL;QACT;QAEA,OAAOK;MACT;EACF;AACF;AAEO,SAASE,OAAOC,SAAgD;EAAA,kCAA5BC;IAAAA;EAAA;EACzC,IAAIA,YAAYC,WAAW,GAAG;IAC5B,OAAOF;EACT;EAEA,IAAIG,kBAAkB;EACtB,IAAIC,mBAAmBJ,QAAQK,QAC7Bf,iBACA,CAACgB,OAAOC,WAAWC,GAAGf,SAAS;IAC7B,MAAMD,aAAaS,YAAYE;IAC/B,MAAMM,QAAQlB,oBAAoBC,YAAYC,IAAI;IAElD,IAAI,CAACc,WAAW;MACdJ;MACA,OAAOM;IACT;IAEA,OAAOH;EACT,CACF;EAGA,IAAIH,kBAAkBF,YAAYC,QAAQ;IACxCE,oBAAoB,IAAIH,YAAYS,MAAMP,eAAe,EAAEQ,KAAK,GAAG;EACrE;EAEAP,mBAAmBA,iBAAiBC,QAAQ,WAAW,GAAG;EAE1D,OAAOD;AACT;;;AC/DA,IAAMQ,yBAAyB;AAO/B,SAASC,gBAAgBC,OAAoB;EAC3C,IAAI,CAACA,MAAMC,OAAO;IAChB;EACF;EAEA,MAAMC,YAAYF,MAAMC,MAAME,MAAM,IAAI;EACxCD,UAAUE,OAAO,GAAGN,sBAAsB;EAC1CE,MAAMC,QAAQC,UAAUL,KAAK,IAAI;AACnC;AAEO,IAAMQ,iBAAN,cAA6BC,MAAM;EAGxCC,YAA4BrB,SAAwC;IAClE,MAAMA,OAAO;IADa;IAF5B,YAAO;IAAA,mCAEyCC;MAAAA;IAAA;IAE9C,KAAKD,UAAUD,OAAOC,SAAS,GAAGC,WAAW;IAC7CY,gBAAgB,IAAI;EACtB;AACF;AA2BO,IAAMS,YAAuB,UAClCC,WACAvB,SAEsB;EACtB,IAAI,CAACuB,WAAW;IAAA,mCAFbtB;MAAAA;IAAA;IAGD,MAAM,IAAIkB,eAAenB,SAAS,GAAGC,WAAW;EAClD;AACF;AAEAqB,UAAUE,KAAK,UAACC,kBAAkBF,WAAWvB,SAA4B;EACvE,IAAI,CAACuB,WAAW;IAAA,mCADuCtB;MAAAA;IAAA;IAErD,MAAMyB,gBAAgBzB,YAAYC,WAAW,IAAIF,UAAUD,OAAOC,SAASC,WAAW;IACtF,IAAIa;IAEJ,IAAI;MACFA,QAAQa,QAAQC,UAAUH,kBAA4C,CAACC,aAAa,CAAC;IACvF,SAAQG,KAAN;MACAf,QAASW,iBAAwCC,aAAa;IAChE;IAEA,MAAMZ;EACR;AACF","names":["POSITIONALS_EXP","serializePositional","positional","flag","Number","JSON","stringify","json","test","format","message","positionals","length","positionalIndex","formattedMessage","replace","match","isEscaped","_","value","slice","join","STACK_FRAMES_TO_IGNORE","cleanErrorStack","error","stack","nextStack","split","splice","InvariantError","Error","constructor","invariant","predicate","as","ErrorConstructor","formatMessage","Reflect","construct","err"],"sources":["/Users/ditole/Desktop/projects/pets-store/node_modules/outvariant/src/format.ts","/Users/ditole/Desktop/projects/pets-store/node_modules/outvariant/src/invariant.ts"],"sourcesContent":["const POSITIONALS_EXP = /(%?)(%([sdijo]))/g\n\nfunction serializePositional(positional: any, flag: string): any {\n  switch (flag) {\n    // Strings.\n    case 's':\n      return positional\n\n    // Digits.\n    case 'd':\n    case 'i':\n      return Number(positional)\n\n    // JSON.\n    case 'j':\n      return JSON.stringify(positional)\n\n    // Objects.\n    case 'o': {\n      // Preserve stings to prevent extra quotes around them.\n      if (typeof positional === 'string') {\n        return positional\n      }\n\n      const json = JSON.stringify(positional)\n\n      // If the positional isn't serializable, return it as-is.\n      if (json === '{}' || json === '[]' || /^\\[object .+?\\]$/.test(json)) {\n        return positional\n      }\n\n      return json\n    }\n  }\n}\n\nexport function format(message: string, ...positionals: any[]): string {\n  if (positionals.length === 0) {\n    return message\n  }\n\n  let positionalIndex = 0\n  let formattedMessage = message.replace(\n    POSITIONALS_EXP,\n    (match, isEscaped, _, flag) => {\n      const positional = positionals[positionalIndex]\n      const value = serializePositional(positional, flag)\n\n      if (!isEscaped) {\n        positionalIndex++\n        return value\n      }\n\n      return match\n    }\n  )\n\n  // Append unresolved positionals to string as-is.\n  if (positionalIndex < positionals.length) {\n    formattedMessage += ` ${positionals.slice(positionalIndex).join(' ')}`\n  }\n\n  formattedMessage = formattedMessage.replace(/%{2,2}/g, '%')\n\n  return formattedMessage\n}\n","import { format } from './format'\n\nconst STACK_FRAMES_TO_IGNORE = 2\n\n/**\n * Remove the \"outvariant\" package trace from the given error.\n * This scopes down the error stack to the relevant parts\n * when used in other applications.\n */\nfunction cleanErrorStack(error: Error): void {\n  if (!error.stack) {\n    return\n  }\n\n  const nextStack = error.stack.split('\\n')\n  nextStack.splice(1, STACK_FRAMES_TO_IGNORE)\n  error.stack = nextStack.join('\\n')\n}\n\nexport class InvariantError extends Error {\n  name = 'Invariant Violation'\n\n  constructor(public readonly message: string, ...positionals: any[]) {\n    super(message)\n    this.message = format(message, ...positionals)\n    cleanErrorStack(this)\n  }\n}\n\nexport interface CustomErrorConstructor {\n  new (message: string): Error\n}\n\nexport interface CustomErrorFactory {\n  (message: string): Error\n}\n\nexport type CustomError = CustomErrorConstructor | CustomErrorFactory\n\ntype Invariant = {\n  (\n    predicate: unknown,\n    message: string,\n    ...positionals: any[]\n  ): asserts predicate\n\n  as(\n    ErrorConstructor: CustomError,\n    predicate: unknown,\n    message: string,\n    ...positionals: unknown[]\n  ): asserts predicate\n}\n\nexport const invariant: Invariant = (\n  predicate,\n  message,\n  ...positionals\n): asserts predicate => {\n  if (!predicate) {\n    throw new InvariantError(message, ...positionals)\n  }\n}\n\ninvariant.as = (ErrorConstructor, predicate, message, ...positionals) => {\n  if (!predicate) {\n    const formatMessage = positionals.length === 0 ? message : format(message, positionals);\n    let error: Error;\n\n    try {\n      error = Reflect.construct(ErrorConstructor as CustomErrorConstructor, [formatMessage]);\n    } catch(err) {\n      error = (ErrorConstructor as CustomErrorFactory)(formatMessage);\n    }\n\n    throw error\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}