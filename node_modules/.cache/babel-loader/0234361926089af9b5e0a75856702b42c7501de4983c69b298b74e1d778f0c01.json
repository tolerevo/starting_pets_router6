{"ast":null,"code":"import statuses from \"@bundled-es-modules/statuses\";\nconst {\n  message\n} = statuses;\nfunction normalizeResponseInit() {\n  let init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const status = init?.status || 200;\n  const statusText = init?.statusText || message[status] || \"\";\n  const headers = new Headers(init?.headers);\n  return {\n    ...init,\n    headers,\n    status,\n    statusText\n  };\n}\nfunction decorateResponse(response, init) {\n  if (init.type) {\n    Object.defineProperty(response, \"type\", {\n      value: init.type,\n      enumerable: true,\n      writable: false\n    });\n  }\n  if (typeof document !== \"undefined\") {\n    const responseCookies = init.headers.get(\"Set-Cookie\")?.split(\",\") || [];\n    for (const cookieString of responseCookies) {\n      document.cookie = cookieString;\n    }\n  }\n  return response;\n}\nexport { decorateResponse, normalizeResponseInit };","map":{"version":3,"mappings":"AAAA,OAAOA,cAAc;AAGrB,MAAM;EAAEC;AAAQ,IAAID;AAQb,SAASE,wBAEa;EAAA,IAD3BC,2EAAyB,CAAC;EAE1B,MAAMC,SAASD,MAAMC,UAAU;EAC/B,MAAMC,aAAaF,MAAME,cAAcJ,QAAQG,MAAM,KAAK;EAC1D,MAAME,UAAU,IAAIC,QAAQJ,MAAMG,OAAO;EAEzC,OAAO;IACL,GAAGH;IACHG;IACAF;IACAC;EACF;AACF;AAEO,SAASG,iBACdC,UACAN,MACU;EAEV,IAAIA,KAAKO,MAAM;IACbC,OAAOC,eAAeH,UAAU,QAAQ;MACtCI,OAAOV,KAAKO;MACZI,YAAY;MACZC,UAAU;IACZ,CAAC;EACH;EAGA,IAAI,OAAOC,aAAa,aAAa;IAKnC,MAAMC,kBAAkBd,KAAKG,QAAQY,IAAI,YAAY,GAAGC,MAAM,GAAG,KAAK,EAAC;IAEvE,WAAWC,gBAAgBH,iBAAiB;MAG1CD,SAASK,SAASD;IACpB;EACF;EAEA,OAAOX;AACT","names":["statuses","message","normalizeResponseInit","init","status","statusText","headers","Headers","decorateResponse","response","type","Object","defineProperty","value","enumerable","writable","document","responseCookies","get","split","cookieString","cookie"],"sources":["/Users/ditole/Desktop/projects/pets-store/node_modules/msw/src/core/utils/HttpResponse/decorators.ts"],"sourcesContent":["import statuses from '@bundled-es-modules/statuses'\nimport type { HttpResponseInit } from '../../HttpResponse'\n\nconst { message } = statuses\n\nexport interface HttpResponseDecoratedInit extends HttpResponseInit {\n  status: number\n  statusText: string\n  headers: Headers\n}\n\nexport function normalizeResponseInit(\n  init: HttpResponseInit = {},\n): HttpResponseDecoratedInit {\n  const status = init?.status || 200\n  const statusText = init?.statusText || message[status] || ''\n  const headers = new Headers(init?.headers)\n\n  return {\n    ...init,\n    headers,\n    status,\n    statusText,\n  }\n}\n\nexport function decorateResponse(\n  response: Response,\n  init: HttpResponseDecoratedInit,\n): Response {\n  // Allow to mock the response type.\n  if (init.type) {\n    Object.defineProperty(response, 'type', {\n      value: init.type,\n      enumerable: true,\n      writable: false,\n    })\n  }\n\n  // Cookie forwarding is only relevant in the browser.\n  if (typeof document !== 'undefined') {\n    // Write the mocked response cookies to the document.\n    // Note that Fetch API Headers will concatenate multiple \"Set-Cookie\"\n    // headers into a single comma-separated string, just as it does\n    // with any other multi-value headers.\n    const responseCookies = init.headers.get('Set-Cookie')?.split(',') || []\n\n    for (const cookieString of responseCookies) {\n      // No need to parse the cookie headers because it's defined\n      // as the valid cookie string to begin with.\n      document.cookie = cookieString\n    }\n  }\n\n  return response\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}