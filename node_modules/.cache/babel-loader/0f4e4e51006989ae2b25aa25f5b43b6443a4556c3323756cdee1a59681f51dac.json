{"ast":null,"code":"// src/MemoryLeakError.ts\nvar MemoryLeakError = class extends Error {\n  constructor(emitter, type, count) {\n    super(`Possible EventEmitter memory leak detected. ${count} ${type.toString()} listeners added. Use emitter.setMaxListeners() to increase limit`);\n    this.emitter = emitter;\n    this.type = type;\n    this.count = count;\n    this.name = \"MaxListenersExceededWarning\";\n  }\n};\n\n// src/Emitter.ts\nvar _Emitter = class {\n  static listenerCount(emitter, eventName) {\n    return emitter.listenerCount(eventName);\n  }\n  constructor() {\n    this.events = /* @__PURE__ */new Map();\n    this.maxListeners = _Emitter.defaultMaxListeners;\n    this.hasWarnedAboutPotentialMemoryLeak = false;\n  }\n  _emitInternalEvent(internalEventName, eventName, listener) {\n    this.emit(internalEventName, ...[eventName, listener]);\n  }\n  _getListeners(eventName) {\n    return Array.prototype.concat.apply([], this.events.get(eventName)) || [];\n  }\n  _removeListener(listeners, listener) {\n    const index = listeners.indexOf(listener);\n    if (index > -1) {\n      listeners.splice(index, 1);\n    }\n    return [];\n  }\n  _wrapOnceListener(eventName, listener) {\n    var _this = this;\n    const onceListener = function () {\n      _this.removeListener(eventName, onceListener);\n      for (var _len = arguments.length, data = new Array(_len), _key = 0; _key < _len; _key++) {\n        data[_key] = arguments[_key];\n      }\n      return listener.apply(_this, data);\n    };\n    Object.defineProperty(onceListener, \"name\", {\n      value: listener.name\n    });\n    return onceListener;\n  }\n  setMaxListeners(maxListeners) {\n    this.maxListeners = maxListeners;\n    return this;\n  }\n  /**\n   * Returns the current max listener value for the `Emitter` which is\n   * either set by `emitter.setMaxListeners(n)` or defaults to\n   * `Emitter.defaultMaxListeners`.\n   */\n  getMaxListeners() {\n    return this.maxListeners;\n  }\n  /**\n   * Returns an array listing the events for which the emitter has registered listeners.\n   * The values in the array will be strings or Symbols.\n   */\n  eventNames() {\n    return Array.from(this.events.keys());\n  }\n  /**\n   * Synchronously calls each of the listeners registered for the event named `eventName`,\n   * in the order they were registered, passing the supplied arguments to each.\n   * Returns `true` if the event has listeners, `false` otherwise.\n   *\n   * @example\n   * const emitter = new Emitter<{ hello: [string] }>()\n   * emitter.emit('hello', 'John')\n   */\n  emit(eventName) {\n    for (var _len2 = arguments.length, data = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      data[_key2 - 1] = arguments[_key2];\n    }\n    const listeners = this._getListeners(eventName);\n    listeners.forEach(listener => {\n      listener.apply(this, data);\n    });\n    return listeners.length > 0;\n  }\n  addListener(eventName, listener) {\n    this._emitInternalEvent(\"newListener\", eventName, listener);\n    const nextListeners = this._getListeners(eventName).concat(listener);\n    this.events.set(eventName, nextListeners);\n    if (this.maxListeners > 0 && this.listenerCount(eventName) > this.maxListeners && !this.hasWarnedAboutPotentialMemoryLeak) {\n      this.hasWarnedAboutPotentialMemoryLeak = true;\n      const memoryLeakWarning = new MemoryLeakError(this, eventName, this.listenerCount(eventName));\n      console.warn(memoryLeakWarning);\n    }\n    return this;\n  }\n  on(eventName, listener) {\n    return this.addListener(eventName, listener);\n  }\n  once(eventName, listener) {\n    return this.addListener(eventName, this._wrapOnceListener(eventName, listener));\n  }\n  prependListener(eventName, listener) {\n    const listeners = this._getListeners(eventName);\n    if (listeners.length > 0) {\n      const nextListeners = [listener].concat(listeners);\n      this.events.set(eventName, nextListeners);\n    } else {\n      this.events.set(eventName, listeners.concat(listener));\n    }\n    return this;\n  }\n  prependOnceListener(eventName, listener) {\n    return this.prependListener(eventName, this._wrapOnceListener(eventName, listener));\n  }\n  removeListener(eventName, listener) {\n    const listeners = this._getListeners(eventName);\n    if (listeners.length > 0) {\n      this._removeListener(listeners, listener);\n      this.events.set(eventName, listeners);\n      this._emitInternalEvent(\"removeListener\", eventName, listener);\n    }\n    return this;\n  }\n  /**\n   * Alias for `emitter.removeListener()`.\n   *\n   * @example\n   * emitter.off('hello', listener)\n   */\n  off(eventName, listener) {\n    return this.removeListener(eventName, listener);\n  }\n  removeAllListeners(eventName) {\n    if (eventName) {\n      this.events.delete(eventName);\n    } else {\n      this.events.clear();\n    }\n    return this;\n  }\n  /**\n   * Returns a copy of the array of listeners for the event named `eventName`.\n   */\n  listeners(eventName) {\n    return Array.from(this._getListeners(eventName));\n  }\n  /**\n   * Returns the number of listeners listening to the event named `eventName`.\n   */\n  listenerCount(eventName) {\n    return this._getListeners(eventName).length;\n  }\n  rawListeners(eventName) {\n    return this.listeners(eventName);\n  }\n};\nvar Emitter = _Emitter;\nEmitter.defaultMaxListeners = 10;\nexport { Emitter, MemoryLeakError };","map":{"version":3,"mappings":"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","names":["MemoryLeakError","Error","constructor","emitter","type","count","toString","name","_Emitter","listenerCount","eventName","events","Map","maxListeners","defaultMaxListeners","hasWarnedAboutPotentialMemoryLeak","_emitInternalEvent","internalEventName","listener","emit","_getListeners","Array","prototype","concat","apply","get","_removeListener","listeners","index","indexOf","splice","_wrapOnceListener","onceListener","_this","removeListener","data","Object","defineProperty","value","setMaxListeners","getMaxListeners","eventNames","from","keys","forEach","length","addListener","nextListeners","set","memoryLeakWarning","console","warn","on","once","prependListener","prependOnceListener","off","removeAllListeners","delete","clear","rawListeners","Emitter"],"sources":["/Users/ditole/Desktop/projects/pets-store/node_modules/strict-event-emitter/src/MemoryLeakError.ts","/Users/ditole/Desktop/projects/pets-store/node_modules/strict-event-emitter/src/Emitter.ts"],"sourcesContent":["import type { Emitter } from './Emitter'\n\nexport class MemoryLeakError extends Error {\n  constructor(\n    public readonly emitter: Emitter<any>,\n    public readonly type: string | number | symbol,\n    public readonly count: number\n  ) {\n    super(\n      `Possible EventEmitter memory leak detected. ${count} ${type.toString()} listeners added. Use emitter.setMaxListeners() to increase limit`\n    )\n    this.name = 'MaxListenersExceededWarning'\n  }\n}\n","import { MemoryLeakError } from './MemoryLeakError'\n\nexport type EventMap = {\n  [eventName: string]: Array<unknown>\n}\n\nexport type InternalEventNames = 'newListener' | 'removeListener'\n\nexport type InternalListener<Events extends EventMap> = Listener<\n  [eventName: keyof Events, listener: Listener<Array<unknown>>]\n>\n\nexport type Listener<Data extends Array<unknown>> = (...data: Data) => void\n\n/**\n * Node.js-compatible implementation of `EventEmitter`.\n *\n * @example\n * const emitter = new Emitter<{ hello: [string] }>()\n * emitter.on('hello', (name) => console.log(name))\n * emitter.emit('hello', 'John')\n */\nexport class Emitter<Events extends EventMap> {\n  private events: Map<keyof Events, Array<Listener<any>>>\n  private maxListeners: number\n  private hasWarnedAboutPotentialMemoryLeak: boolean\n\n  static defaultMaxListeners = 10\n\n  static listenerCount<Events extends EventMap>(\n    emitter: Emitter<EventMap>,\n    eventName: keyof Events\n  ): number {\n    return emitter.listenerCount<any>(eventName)\n  }\n\n  constructor() {\n    this.events = new Map()\n    this.maxListeners = Emitter.defaultMaxListeners\n    this.hasWarnedAboutPotentialMemoryLeak = false\n  }\n\n  private _emitInternalEvent(\n    internalEventName: InternalEventNames,\n    eventName: keyof Events,\n    listener: Listener<Array<unknown>>\n  ): void {\n    this.emit(\n      internalEventName,\n      // Anything to make TypeScript happy.\n      ...([eventName, listener] as Events['newListener'] &\n        Events['removeListener'])\n    )\n  }\n\n  private _getListeners<EventName extends keyof Events>(\n    eventName: EventName\n  ): Array<Listener<Array<unknown>>> {\n    // Always return a copy of the listeners array\n    // so they are fixed at the time of the \"_getListeners\" call.\n    return Array.prototype.concat.apply([], this.events.get(eventName)) || []\n  }\n\n  private _removeListener<EventName extends keyof Events>(\n    listeners: Array<Listener<Events[EventName]>>,\n    listener: Listener<Events[EventName]>\n  ): Array<Listener<Events[EventName]>> {\n    const index = listeners.indexOf(listener)\n\n    if (index > -1) {\n      listeners.splice(index, 1)\n    }\n\n    return []\n  }\n\n  private _wrapOnceListener<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): Listener<Events[EventName]> {\n    const onceListener = (...data: Events[keyof Events]) => {\n      this.removeListener(eventName, onceListener)\n\n      /**\n       * @note Return the result of the original listener.\n       * This way this wrapped preserves listeners that are async.\n       */\n      return listener.apply(this, data)\n    }\n\n    // Inherit the name of the original listener.\n    Object.defineProperty(onceListener, 'name', { value: listener.name })\n\n    return onceListener\n  }\n\n  public setMaxListeners(maxListeners: number): this {\n    this.maxListeners = maxListeners\n    return this\n  }\n\n  /**\n   * Returns the current max listener value for the `Emitter` which is\n   * either set by `emitter.setMaxListeners(n)` or defaults to\n   * `Emitter.defaultMaxListeners`.\n   */\n  public getMaxListeners(): number {\n    return this.maxListeners\n  }\n\n  /**\n   * Returns an array listing the events for which the emitter has registered listeners.\n   * The values in the array will be strings or Symbols.\n   */\n  public eventNames(): Array<keyof Events> {\n    return Array.from(this.events.keys())\n  }\n\n  /**\n   * Synchronously calls each of the listeners registered for the event named `eventName`,\n   * in the order they were registered, passing the supplied arguments to each.\n   * Returns `true` if the event has listeners, `false` otherwise.\n   *\n   * @example\n   * const emitter = new Emitter<{ hello: [string] }>()\n   * emitter.emit('hello', 'John')\n   */\n  public emit<EventName extends keyof Events>(\n    eventName: EventName,\n    ...data: Events[EventName]\n  ): boolean {\n    const listeners = this._getListeners(eventName)\n    listeners.forEach((listener) => {\n      listener.apply(this, data)\n    })\n\n    return listeners.length > 0\n  }\n\n  public addListener(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public addListener<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public addListener(\n    eventName: InternalEventNames | keyof Events,\n    listener: InternalListener<Events> | Listener<Events[any]>\n  ): this {\n    // Emit the `newListener` event before adding the listener.\n    this._emitInternalEvent('newListener', eventName, listener)\n\n    const nextListeners = this._getListeners(eventName).concat(listener)\n    this.events.set(eventName, nextListeners)\n\n    if (\n      this.maxListeners > 0 &&\n      this.listenerCount(eventName) > this.maxListeners &&\n      !this.hasWarnedAboutPotentialMemoryLeak\n    ) {\n      this.hasWarnedAboutPotentialMemoryLeak = true\n\n      const memoryLeakWarning = new MemoryLeakError(\n        this,\n        eventName,\n        this.listenerCount(eventName)\n      )\n      console.warn(memoryLeakWarning)\n    }\n\n    return this\n  }\n\n  public on(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public on<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public on<EventName extends keyof Events>(\n    eventName: 'removeListener' | EventName,\n    listener: Listener<any>\n  ): this {\n    return this.addListener(eventName, listener)\n  }\n\n  public once(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public once<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public once<EventName extends keyof Events>(\n    eventName: InternalEventNames | EventName,\n    listener: Listener<any>\n  ): this {\n    return this.addListener(\n      eventName,\n      this._wrapOnceListener(eventName, listener)\n    )\n  }\n\n  public prependListener(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public prependListener<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public prependListener(\n    eventName: InternalEventNames | keyof Events,\n    listener: Listener<any>\n  ): this {\n    const listeners = this._getListeners(eventName)\n\n    if (listeners.length > 0) {\n      const nextListeners = [listener].concat(listeners)\n      this.events.set(eventName, nextListeners)\n    } else {\n      this.events.set(eventName, listeners.concat(listener))\n    }\n\n    return this\n  }\n\n  public prependOnceListener(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public prependOnceListener<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public prependOnceListener(\n    eventName: InternalEventNames | keyof Events,\n    listener: Listener<any>\n  ): this {\n    return this.prependListener(\n      eventName,\n      this._wrapOnceListener(eventName, listener)\n    )\n  }\n\n  public removeListener(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public removeListener<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public removeListener(\n    eventName: InternalEventNames | keyof Events,\n    listener: Listener<any>\n  ): this {\n    const listeners = this._getListeners(eventName)\n\n    if (listeners.length > 0) {\n      this._removeListener(listeners, listener)\n      this.events.set(eventName, listeners)\n\n      // Emit the `removeListener` event after removing the listener.\n      this._emitInternalEvent('removeListener', eventName, listener)\n    }\n\n    return this\n  }\n\n  public off(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public off<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  /**\n   * Alias for `emitter.removeListener()`.\n   *\n   * @example\n   * emitter.off('hello', listener)\n   */\n  public off(\n    eventName: InternalEventNames | keyof Events,\n    listener: Listener<any>\n  ): this {\n    return this.removeListener(eventName, listener)\n  }\n\n  public removeAllListeners(eventName?: InternalEventNames): this\n  public removeAllListeners<EventName extends keyof Events>(\n    eventName?: EventName\n  ): this\n  public removeAllListeners(\n    eventName?: InternalEventNames | keyof Events\n  ): this {\n    if (eventName) {\n      this.events.delete(eventName)\n    } else {\n      this.events.clear()\n    }\n\n    return this\n  }\n\n  public listeners(eventName: InternalEventNames): Array<Listener<any>>\n  public listeners<EventName extends keyof Events>(\n    eventName: EventName\n  ): Array<Listener<Events[EventName]>>\n  /**\n   * Returns a copy of the array of listeners for the event named `eventName`.\n   */\n  public listeners(eventName: InternalEventNames | keyof Events) {\n    return Array.from(this._getListeners(eventName))\n  }\n\n  public listenerCount(eventName: InternalEventNames): number\n  public listenerCount<EventName extends keyof Events>(\n    eventName: EventName\n  ): number\n  /**\n   * Returns the number of listeners listening to the event named `eventName`.\n   */\n  public listenerCount(eventName: InternalEventNames | keyof Events): number {\n    return this._getListeners(eventName).length\n  }\n\n  public rawListeners<EventName extends keyof Events>(\n    eventName: EventName\n  ): Array<Listener<Events[EventName]>> {\n    return this.listeners(eventName)\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}