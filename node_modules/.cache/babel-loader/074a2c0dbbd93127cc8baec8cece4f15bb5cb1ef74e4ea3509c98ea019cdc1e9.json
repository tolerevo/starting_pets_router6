{"ast":null,"code":"import { until } from \"@open-draft/until\";\nimport { executeHandlers } from './executeHandlers.mjs';\nimport { onUnhandledRequest } from './request/onUnhandledRequest.mjs';\nimport { readResponseCookies } from './request/readResponseCookies.mjs';\nasync function handleRequest(request, requestId, handlers, options, emitter, handleRequestOptions) {\n  emitter.emit(\"request:start\", {\n    request,\n    requestId\n  });\n  if (request.headers.get(\"x-msw-intention\") === \"bypass\") {\n    emitter.emit(\"request:end\", {\n      request,\n      requestId\n    });\n    handleRequestOptions?.onPassthroughResponse?.(request);\n    return;\n  }\n  const lookupResult = await until(() => {\n    return executeHandlers({\n      request,\n      requestId,\n      handlers,\n      resolutionContext: handleRequestOptions?.resolutionContext\n    });\n  });\n  if (lookupResult.error) {\n    emitter.emit(\"unhandledException\", {\n      error: lookupResult.error,\n      request,\n      requestId\n    });\n    throw lookupResult.error;\n  }\n  if (!lookupResult.data) {\n    await onUnhandledRequest(request, options.onUnhandledRequest);\n    emitter.emit(\"request:unhandled\", {\n      request,\n      requestId\n    });\n    emitter.emit(\"request:end\", {\n      request,\n      requestId\n    });\n    handleRequestOptions?.onPassthroughResponse?.(request);\n    return;\n  }\n  const {\n    response\n  } = lookupResult.data;\n  if (!response) {\n    emitter.emit(\"request:end\", {\n      request,\n      requestId\n    });\n    handleRequestOptions?.onPassthroughResponse?.(request);\n    return;\n  }\n  if (response.status === 302 && response.headers.get(\"x-msw-intention\") === \"passthrough\") {\n    emitter.emit(\"request:end\", {\n      request,\n      requestId\n    });\n    handleRequestOptions?.onPassthroughResponse?.(request);\n    return;\n  }\n  readResponseCookies(request, response);\n  emitter.emit(\"request:match\", {\n    request,\n    requestId\n  });\n  const requiredLookupResult = lookupResult.data;\n  const transformedResponse = handleRequestOptions?.transformResponse?.(response) || response;\n  handleRequestOptions?.onMockedResponse?.(transformedResponse, requiredLookupResult);\n  emitter.emit(\"request:end\", {\n    request,\n    requestId\n  });\n  return transformedResponse;\n}\nexport { handleRequest };","map":{"version":3,"mappings":"AAAA,SAASA,aAAa;AAKtB,SAAkCC,uBAAuB;AACzD,SAASC,0BAA0B;AACnC,SAASC,2BAA2B;AAqCpC,eAAsBC,cACpBC,SACAC,WACAC,UACAC,SACAC,SACAC,sBAC+B;EAC/BD,QAAQE,KAAK,iBAAiB;IAAEN;IAASC;EAAU,CAAC;EAGpD,IAAID,QAAQO,QAAQC,IAAI,iBAAiB,MAAM,UAAU;IACvDJ,QAAQE,KAAK,eAAe;MAAEN;MAASC;IAAU,CAAC;IAClDI,sBAAsBI,wBAAwBT,OAAO;IACrD;EACF;EAGA,MAAMU,eAAe,MAAMf,MAAM,MAAM;IACrC,OAAOC,gBAAgB;MACrBI;MACAC;MACAC;MACAS,mBAAmBN,sBAAsBM;IAC3C,CAAC;EACH,CAAC;EAED,IAAID,aAAaE,OAAO;IAEtBR,QAAQE,KAAK,sBAAsB;MACjCM,OAAOF,aAAaE;MACpBZ;MACAC;IACF,CAAC;IACD,MAAMS,aAAaE;EACrB;EAIA,IAAI,CAACF,aAAaG,MAAM;IACtB,MAAMhB,mBAAmBG,SAASG,QAAQN,kBAAkB;IAC5DO,QAAQE,KAAK,qBAAqB;MAAEN;MAASC;IAAU,CAAC;IACxDG,QAAQE,KAAK,eAAe;MAAEN;MAASC;IAAU,CAAC;IAClDI,sBAAsBI,wBAAwBT,OAAO;IACrD;EACF;EAEA,MAAM;IAAEc;EAAS,IAAIJ,aAAaG;EAIlC,IAAI,CAACC,UAAU;IACbV,QAAQE,KAAK,eAAe;MAAEN;MAASC;IAAU,CAAC;IAClDI,sBAAsBI,wBAAwBT,OAAO;IACrD;EACF;EAIA,IACEc,SAASC,WAAW,OACpBD,SAASP,QAAQC,IAAI,iBAAiB,MAAM,eAC5C;IACAJ,QAAQE,KAAK,eAAe;MAAEN;MAASC;IAAU,CAAC;IAClDI,sBAAsBI,wBAAwBT,OAAO;IACrD;EACF;EAGAF,oBAAoBE,SAASc,QAAQ;EAErCV,QAAQE,KAAK,iBAAiB;IAAEN;IAASC;EAAU,CAAC;EAEpD,MAAMe,uBACJN,aAAaG;EAEf,MAAMI,sBACJZ,sBAAsBa,oBAAoBJ,QAAQ,KACjDA;EAEHT,sBAAsBc,mBACpBF,qBACAD,oBACF;EAEAZ,QAAQE,KAAK,eAAe;IAAEN;IAASC;EAAU,CAAC;EAElD,OAAOgB;AACT","names":["until","executeHandlers","onUnhandledRequest","readResponseCookies","handleRequest","request","requestId","handlers","options","emitter","handleRequestOptions","emit","headers","get","onPassthroughResponse","lookupResult","resolutionContext","error","data","response","status","requiredLookupResult","transformedResponse","transformResponse","onMockedResponse"],"sources":["/Users/ditole/Desktop/projects/pets-store/node_modules/msw/src/core/utils/handleRequest.ts"],"sourcesContent":["import { until } from '@open-draft/until'\nimport { Emitter } from 'strict-event-emitter'\nimport { RequestHandler } from '../handlers/RequestHandler'\nimport { LifeCycleEventsMap, SharedOptions } from '../sharedOptions'\nimport { RequiredDeep } from '../typeUtils'\nimport { HandlersExecutionResult, executeHandlers } from './executeHandlers'\nimport { onUnhandledRequest } from './request/onUnhandledRequest'\nimport { readResponseCookies } from './request/readResponseCookies'\n\nexport interface HandleRequestOptions {\n  /**\n   * `resolutionContext` is not part of the general public api\n   * but is exposed to aid in creating extensions like\n   * `@mswjs/http-middleware`.\n   */\n  resolutionContext?: {\n    /**\n     * A base url to use when resolving relative urls.\n     * @note This is primarily used by the `@mswjs/http-middleware`\n     * to resolve relative urls in the context of the running server\n     */\n    baseUrl?: string\n  }\n\n  /**\n   * Transforms a `MockedResponse` instance returned from a handler\n   * to a response instance supported by the lower tooling (i.e. interceptors).\n   */\n  transformResponse?(response: Response): Response\n\n  /**\n   * Invoked whenever a request is performed as-is.\n   */\n  onPassthroughResponse?(request: Request): void\n\n  /**\n   * Invoked when the mocked response is ready to be sent.\n   */\n  onMockedResponse?(\n    response: Response,\n    handler: RequiredDeep<HandlersExecutionResult>,\n  ): void\n}\n\nexport async function handleRequest(\n  request: Request,\n  requestId: string,\n  handlers: Array<RequestHandler>,\n  options: RequiredDeep<SharedOptions>,\n  emitter: Emitter<LifeCycleEventsMap>,\n  handleRequestOptions?: HandleRequestOptions,\n): Promise<Response | undefined> {\n  emitter.emit('request:start', { request, requestId })\n\n  // Perform bypassed requests (i.e. issued via \"ctx.fetch\") as-is.\n  if (request.headers.get('x-msw-intention') === 'bypass') {\n    emitter.emit('request:end', { request, requestId })\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  // Resolve a mocked response from the list of request handlers.\n  const lookupResult = await until(() => {\n    return executeHandlers({\n      request,\n      requestId,\n      handlers,\n      resolutionContext: handleRequestOptions?.resolutionContext,\n    })\n  })\n\n  if (lookupResult.error) {\n    // Allow developers to react to unhandled exceptions in request handlers.\n    emitter.emit('unhandledException', {\n      error: lookupResult.error,\n      request,\n      requestId,\n    })\n    throw lookupResult.error\n  }\n\n  // If the handler lookup returned nothing, no request handler was found\n  // matching this request. Report the request as unhandled.\n  if (!lookupResult.data) {\n    await onUnhandledRequest(request, options.onUnhandledRequest)\n    emitter.emit('request:unhandled', { request, requestId })\n    emitter.emit('request:end', { request, requestId })\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  const { response } = lookupResult.data\n\n  // When the handled request returned no mocked response, warn the developer,\n  // as it may be an oversight on their part. Perform the request as-is.\n  if (!response) {\n    emitter.emit('request:end', { request, requestId })\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  // Perform the request as-is when the developer explicitly returned \"req.passthrough()\".\n  // This produces no warning as the request was handled.\n  if (\n    response.status === 302 &&\n    response.headers.get('x-msw-intention') === 'passthrough'\n  ) {\n    emitter.emit('request:end', { request, requestId })\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  // Store all the received response cookies in the virtual cookie store.\n  readResponseCookies(request, response)\n\n  emitter.emit('request:match', { request, requestId })\n\n  const requiredLookupResult =\n    lookupResult.data as RequiredDeep<HandlersExecutionResult>\n\n  const transformedResponse =\n    handleRequestOptions?.transformResponse?.(response) ||\n    (response as any as Response)\n\n  handleRequestOptions?.onMockedResponse?.(\n    transformedResponse,\n    requiredLookupResult,\n  )\n\n  emitter.emit('request:end', { request, requestId })\n\n  return transformedResponse\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}